ABSTRACT
Symbolic backwards execution (SBE) is a useful variation on standard forward symbolic evaluation; it allows a symbolic evaluation to start anywhere in the program and proceed by executing in reverse to the program start. SBE brings goal directed reasoning to symbolic evaluation and has proven effective in e.g. automated test generation for imperative languages.
In this paper we define DDSE, a novel SBE which operates on a functional as opposed to imperative language; furthermore, it is defined as a natural extension of a backwards executing interpreter. We establish the soundness of DDSE and define a test generation algorithm for this toy language. We report on an initial reference implementation to confirm the correctness of the principles.

1. INTRODUCTION
Symbolic execution, the evaluation of a program over symbolic ranges of values instead of over concrete values, has proven to be a useful technique with real world applications from lightweight program verification to automated test generation; see [Baldoni et al. 2018] for a recent survey of the area. Path explosion is a major shortcoming with symbolic execution: a vast number of the explored paths never get near the target program point in forward runs. A backward running approach can avoid searching many of those paths.
This paper focuses on symbolic backwards execution (SBE) [Baldoni et al. 2018, ยง2.3], a variation on symbolic evaluation where evaluation can start at any point in the program and proceed in reverse to the program start. This reverse propagation is similar in spirit to how Dijkstra weakest preconditions (wps) are propagated, and how classic backward program analyses propagate constraints in reverse. The advantage of SBE is the same as any goal directed reasoning: by focusing on the goal from the start, there are fewer spurious paths taken.
SBEs have been developed for imperative languages; examples include [Chandra et al. 2009; Charreteur and Gotlieb 2010; Dinges and Agha 2014; Ma et al. 2011]. These reverse techniques are useful for goal directed reasoning about paths leading to a particular program point: if a condition at a program point can be propagated back to the program start, this will deduce its validity. The aforecited systems are capable of automatically generating tests exercising a particular program point, using backward symbolic execution to accumulate constraints required to reach the target. To be clear: SBE does not single handedly solve the problem of symbolic execution performance, but it is a fundamentally different approach that has advantages in some contexts.
These imperative language systems do not directly generalize to functional languages. Functional languages have a combination of non local variables and a control flow that can itself depend on (function) data flow which makes this gap non trivial. In this paper, we develop DDSE: a demand driven symbolic evaluator for higher order functional languages which also propagates constraints backwards. We show how, unlike existing SBEs, DDSE may be constructed as a direct generalization of a backward concrete evaluator; this follows how forward symbolic evaluators are constructed as generalizations of forward concrete evaluators and lends a regularity to the process. With this regularity it is also possible to formally prove DDSE is correct, something not previously proven for any SBE. In order to show applicability of DDSE, we develop a theory and implementation of test generation for a functional language. While the paper focuses on the test generation application to show that concrete results are possible, DDSE is also applicable to other goal directed problems that SBEs can address.
There exist demand driven program analyses in parallel with demand driven symbolic evaluators, both for imperative languages [Horwitz et al. 1995] and more recently for functional languages [Facchinetti et al. 2019; Germane et al. 2019]; DDSE is built on the infrastructure of one particular higher order demand driven program analysis, DDPA [Facchinetti et al. 2019].
In Section 2 we give a high level overview of the principles behind the approach. Section 3 defines a novel demand driven operational semantics which serves as the basis of our symbolic demand driven evaluator. Section 4 extends the demand driven operational semantics to symbolic DDSE and shows how it can be used for test generation. We formally prove that the symbolic interpreter extends the concrete one, and that tests inferred will in fact exercise the indicated line of code they were supposed to. Section 5 describes the implementation of the test generation algorithm and its performance on small benchmarks. Section 6 gives related work, and we conclude in Section 7. Proofs are found in the Appendices.

2. OVERVIEW
Goal directed program reasoning has a long tradition in programming languages, dating back to Dijkstra weakest precondition (wp) propagation. We review a very simple example in Figure 1 to recollect wp propagation.
Suppose we started at line 6 with true as our (vacuous) assertion. By wp propagation since we know we are coming only from the true branch of the conditional, before line 3 we must have precondition {x < 25}, and continuing to propagate, we have {x > 0 โง x < 25} in line 2. So, it means that input must be in the range of 1 ... 24 for the target line 6 to be reached. This example gives some idea of how existing first order symbolic backward executors (SBEs) [Chandra et al. 2009; Dinges and Agha 2014] work: they start with a vacuous precondition and back propagate to the start of the program.
The goal of this paper is to show how a demand driven symbolic evaluator can be developed for higher order functional languages. Weakest precondition logic was designed for first order stateful programs, and we aim to design a similar reverse propagation for functional programs.
Recall that the general case of higher order functions includes two key differences from first order programs: functions are passed as data, thus causing data flow to influence control flow, and function bodies capture non local variables in closures. The aforecited systems give partial consideration of higher order functions: they accommodate virtual method calls by an iterative process for estimating the call graph. However, no soundness properties are claimed in those works. By starting with a higher order functional basis, we can develop a direct and provably sound demand driven symbolic evaluator. We will describe DDSE in stages here: first defining the demand driven evaluator, then extending it to deal with input, and finally performing symbolic evaluation starting from an arbitrary program point.